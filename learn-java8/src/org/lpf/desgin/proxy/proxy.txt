代理模式
    代理解决的问题当两个类需要通信时，引入第三方代理类，将两个类的关系解耦，让我们只了解代理类即可
    eg: 经纪人,律师,中介...
    特点- 1:角色 , 被代理者,执行者
      2:被代理者必须要做的事情,却没时间或者不能做的,则需要代理
      3:被代理者需要向执行者提供资料(基本信息,要求...)
      
    代理模式分为两种:静态代理和动态代理。
    different: 1) 静态代理是由程序员创建代理类或者特定工具自动生成源代码并对其编译,程序在运行之前.class文件已经存在。
                                                 动态代理在程序运行期,通过反射机制动态创建的.
               2) 静态代理的缺点代理类(执行者)和委托类(被代理者)实现相同的接口,代理类通过委托类实现了相同的方法,这样就出现了大量的代码重复.
                                                当接口改变时,委托类和代理类都要实现改变的方法,增加了代码维护的复杂度.不易维护。
                                                静态代理只服务于一种类型的对象,如果需要服务多类型的对象,就需要对每一种对象进行代理,静态代理在程序规模稍大时就无法胜任了.
               3) 动态代理机制需要 java.lang.reflect.InvocationHandler接口和java.lang.reflect.Proxy 的支持
                                                动态代理最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理(InvocationHandler.invoke()),
                                                这样,在接口方法数量比较多的时候,可以进行灵活处理.并且动态代理的应用使我们的类职责更加单一,复用性更强.
 
    静态代理(static proxy)
    Source类为 被代理对象(委托类),SourceProxy为执行者(代理类),两者共同实现Sourceable接口.
    SourceProxy中持有Source类的引用,实现接口方法时都会调用Source对应的方法.
    Test(客户端)只和SourceProxy类打交道.
    
    动态代理 分为两种 jdk提供的代理机制和 cglib代理.
    jdk代理需要InvocationHandler和Proxy的支持.委托类必须有实现的接口，否则不能生成代理.Proxy.newProxyInstance()方法生成代理对象
        jdk代理,委托类和代理类实现共同的接口,动态字节码生成加载到jvm中 生成出代理类.在增强程序中 调用 method.invoke(委托类对象,参数),若参数为代理类对象则陷入死循环.
    CGLIB代理是通过派生出 委托类的子类 来生成代理. 通过增强器来生成 继承委托类的代理类. 委托类不用实现接口依然能够生成代理,final声明的方法不能被代理
                    代理类 实现 MethodInterceptor(方法拦截器)接口来实现增强代码 和 Enhancer(增强器)去动态创建代理类.在增强程序中 methodProxy.invokeSuper(),
                    若使用 method.invoke(),则陷入死循环.
    
    jdk代理和CGLIB代理的区别： 1.使用jdk代理委托类必须有实现的接口,否则不能生成代理.CGLIB代理委托类不实现接口依然能够生成代理.
                         2. jdk代理原理是  代理类实现委托类所有接口,并且持有委托类的实例. CGLIB是通过继承委托类来生成代理类.
                         3.使用jdk代理,委托类中被final声明的方法依然能够代理.CGLIB则不能为final声明的方法去增强.

代理模式的应用场景：

如果已有的方法在使用的时候需要对原有的方法进行改进，此时有两种办法：

1、修改原有的方法来适应。这样违反了“对扩展开放，对修改关闭”的原则。

2、就是采用一个代理类调用原有的方法，且对产生的结果进行控制。这种方法就是代理模式。

使用代理模式，可以将功能划分的更加清晰，有助于后期维护！                                            